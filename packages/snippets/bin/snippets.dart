// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:args/args.dart';
import 'package:path/path.dart' as path;
import 'package:snippets/snippets.dart';

const String _kSerialOption = 'serial';
const String _kElementOption = 'element';
const String _kHelpOption = 'help';
const String _kInputOption = 'input';
const String _kLibraryOption = 'library';
const String _kOutputOption = 'output';
const String _kPackageOption = 'package';
const String _kTemplateOption = 'template';
const String _kTypeOption = 'type';

String getChannelName() {
  final RegExp gitBranchRegexp = RegExp(r'^## (?<branch>.*)');
  final ProcessResult gitResult = Process.runSync('git', <String>['status', '-b', '--porcelain']);
  if (gitResult.exitCode != 0)
    throw 'git status exit with non-zero exit code: ${gitResult.exitCode}';
  final RegExpMatch? gitBranchMatch =
      gitBranchRegexp.firstMatch((gitResult.stdout as String).trim().split('\n').first);
  return gitBranchMatch == null
      ? '<unknown>'
      : gitBranchMatch.namedGroup('branch')!.split('...').first;
}

List<Line> getLinesFromInput(
    {int? startLine,
    String? element,
    required File input,
    required String type,
    required String template}) {
  final List<Line> inputLines = <Line>[];
  int lineNumber = startLine ?? 0;
  for (final String line in <String>[
    // The parser wants to read the arguments from the input, so we create a new
    // tool line to match the given arguments, so that we can use the same parser for
    // editing and docs generation.
    '/// {@tool $type${template.isNotEmpty ? ' --template=$template}' : ''}}',
    // Snippet input comes in with the comment markers stripped, so we add them
    // back to make it conform to the source format, so we can use the same
    // parser for editing samples as we do for processing docs.
    ...input.readAsLinesSync().map<String>((String line) => '/// $line'),
    '/// {@end-tool}',
  ]) {
    inputLines.add(
      Line(line, element: element ?? '', line: lineNumber),
    );
    lineNumber++;
  }
  return inputLines;
}

/// Generates snippet dartdoc output for a given input, and creates any sample
/// applications needed by the snippet.
void main(List<String> argList) {
  final Map<String, String> environment = Platform.environment;
  final ArgParser parser = ArgParser();
  final List<String> snippetTypes =
      SampleType.values.map<String>((SampleType type) => getEnumName(type)).toList();
  parser.addOption(
    _kTypeOption,
    defaultsTo: getEnumName(SampleType.dartpad),
    allowed: snippetTypes,
    allowedHelp: <String, String>{
      getEnumName(SampleType.dartpad):
          'Produce a code sample application complete with embedding the sample in an '
              'application template.',
      getEnumName(SampleType.sample):
          'Produce a code sample application complete with embedding the sample in an '
              'application template.',
      getEnumName(SampleType.snippet):
          'Produce a nicely formatted piece of sample code. Does not embed the '
              'sample into an application template.',
    },
    help: 'The type of snippet to produce.',
  );
  parser.addOption(
    _kTemplateOption,
    defaultsTo: null,
    help: 'The name of the template to inject the code into.',
  );
  parser.addOption(
    _kOutputOption,
    defaultsTo: null,
    help: 'The output path for the generated sample application. Overrides '
        'the naming generated by the --package/--library/--element arguments. '
        'Metadata will be written alongside in a .json file. '
        'The basename of this argument is used as the ID',
  );
  parser.addOption(
    _kInputOption,
    defaultsTo: environment['INPUT'],
    help: 'The input file containing the sample code to inject.',
  );
  parser.addOption(
    _kPackageOption,
    defaultsTo: environment['PACKAGE_NAME'],
    help: 'The name of the package that this sample belongs to.',
  );
  parser.addOption(
    _kLibraryOption,
    defaultsTo: environment['LIBRARY_NAME'],
    help: 'The name of the library that this sample belongs to.',
  );
  parser.addOption(
    _kElementOption,
    defaultsTo: environment['ELEMENT_NAME'],
    help: 'The name of the element that this sample belongs to.',
  );
  parser.addOption(
    _kSerialOption,
    defaultsTo: environment['INVOCATION_INDEX'],
    help: 'A unique serial number for this snippet tool invocation.',
  );
  parser.addFlag(
    _kHelpOption,
    defaultsTo: false,
    negatable: false,
    help: 'Prints help documentation for this command',
  );

  final ArgResults args = parser.parse(argList);

  if (args[_kHelpOption] as bool) {
    stderr.writeln(parser.usage);
    exit(0);
  }

  final SampleType snippetType =
      SampleType.values.firstWhere((SampleType type) => getEnumName(type) == args[_kTypeOption]);

  if (args[_kInputOption] == null) {
    stderr.writeln(parser.usage);
    errorExit('The --$_kInputOption option must be specified, either on the command '
        'line, or in the INPUT environment variable.');
  }

  final File input = File(args['input'] as String);
  if (!input.existsSync()) {
    errorExit('The input file ${input.path} does not exist.');
  }

  String? template;
  if (snippetType == SampleType.sample || snippetType == SampleType.dartpad) {
    final String templateArg = args[_kTemplateOption] as String;
    if (templateArg == null || templateArg.isEmpty) {
      stderr.writeln(parser.usage);
      errorExit('The --$_kTemplateOption option must be specified on the command '
          'line for application samples.');
    }
    template = templateArg.replaceAll(RegExp(r'.tmpl$'), '');
  }

  final String packageName = args[_kPackageOption] as String? ?? '';
  final String libraryName = args[_kLibraryOption] as String? ?? '';
  final String elementName = args[_kElementOption] as String? ?? '';
  final String serial = args[_kSerialOption] as String? ?? '';
  final List<String> id = <String>[];
  File? output;
  if (args[_kOutputOption] != null) {
    id.add(path.basename(path.basenameWithoutExtension(args[_kOutputOption] as String)));
    output = File(path.absolute(args[_kOutputOption] as String));
  } else {
    if (packageName.isNotEmpty && packageName != 'flutter') {
      id.add(packageName);
    }
    if (libraryName.isNotEmpty) {
      id.add(libraryName);
    }
    if (elementName.isNotEmpty) {
      id.add(elementName);
    }
    if (serial.isNotEmpty) {
      id.add(serial);
    }
    if (id.isEmpty) {
      errorExit('Unable to determine ID. At least one of --$_kPackageOption, '
          '--$_kLibraryOption, --$_kElementOption, -$_kSerialOption, or the environment variables '
          'PACKAGE_NAME, LIBRARY_NAME, ELEMENT_NAME, or INVOCATION_INDEX must be non-empty.');
    }
  }

  final int? sourceLine =
      environment['SOURCE_LINE'] != null ? int.tryParse(environment['SOURCE_LINE']!) : null;
  final List<Line> lines = getLinesFromInput(
    input: input,
    startLine: sourceLine,
    element: elementName,
    template: template!,
    type: getEnumName(snippetType),
  );
  final SnippetDartdocParser snippetParser = SnippetDartdocParser();
  final List<CodeSample> samples = snippetParser.parseFromComments(<List<Line>>[lines]);

  final SnippetGenerator generator = SnippetGenerator();
  final Map<String, Object?> metadata = <String, Object?>{
    'sourcePath': environment['SOURCE_PATH'],
    'sourceLine': sourceLine,
    'id': id.join('.'),
    'channel': getChannelName(),
    'serial': serial,
    'package': packageName,
    'library': libraryName,
    'element': elementName,
  };
  for (final CodeSample sample in samples) {
    generator.generateCode(
      sample,
      template: template,
      metadata: metadata,
      output: output,
    );
    print(generator.generateHtml(sample, metadata: metadata));
  }

  exit(0);
}
